<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LM Advogados - Jogo da Memória</title>
    <link rel="icon" href="">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/canvas-confetti/1.9.2/confetti.browser.min.js"></script>
    <style>
        :root {
            /* --- PALETA DE CORES "LARA MARTINS ADVOGADOS" --- */
            --color-primary: #232b56;
            /* Azul Marinho (Fundo Principal, Texto Escuro) */
            --color-secondary: #759e56;
            /* Verde (Botões Primários, Destaques)  */
            --color-accent: #d3cc9e;
            /* Bege (Painéis, Texto Claro) */
            --color-background: var(--color-primary);
            --color-panel: var(--color-accent);
            --color-text-on-dark: var(--color-accent);
            --color-text-on-light: var(--color-primary);
            --color-error: #a83232;
            --color-focus-outline: #232b56;

            /* --- Efeitos de Sombra e Brilho --- */
            --success-glow: rgba(117, 158, 86, 0.7);
            --error-glow: rgba(168, 50, 50, 0.6);
            --shadow-subtle: rgba(0, 0, 0, 0.08);
            --shadow-medium: rgba(0, 0, 0, 0.12);
            --shadow-dark: rgba(0, 0, 0, 0.16);

            /* --- Unidades Fluidas com clamp() para escalonamento --- */
            --radius-panel: clamp(16px, 2vmin, 24px);
            --radius-btn: clamp(10px, 1.2vmin, 14px);
            --radius-card: clamp(8px, 1vmin, 12px);
            --radius-inner: clamp(6px, 0.8vmin, 10px);

            --padding-card: clamp(6px, 1vmin, 6px);
            --padding-md: clamp(1rem, 2vmin, 2rem);
            --padding-lg: clamp(1.5rem, 3vmin, 3rem);

            --gap-sm: clamp(0.5rem, 1.5vmin, 1rem);
            --gap-md: clamp(0.75rem, 2.5vmin, 1.5rem);

            --gap-sm-maior: clamp(1.5rem, 2.5vmin, 2.75rem);
            /* Ex: Mais espaço */

            /* --- Tipografia Fluida com clamp() --- */
            --font-family: 'Inter', sans-serif;
            --font-size-md: clamp(1rem, 2.2vmin, 1.15rem);
            --font-size-lg: clamp(1.2rem, 2.8vmin, 1.5rem);
            --font-size-xl: clamp(1.5rem, 3.5vmin, 2.25rem);
            --font-size-xxl: clamp(2rem, 4.5vmin, 3rem);

            --flip-duration: 0.5s;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--color-background);
            color: var(--color-text-on-dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            max-height: 100vh;
            padding: var(--gap-md);
            text-align: center;
            overflow: hidden;
            position: relative;
        }

        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(35, 43, 86, 0) 0%, rgba(35, 43, 86, 1) 100%);
            z-index: -1;
        }

        :focus-visible {
            outline: 2px solid var(--color-focus-outline);
            box-shadow: 0 0 10px var(--color-focus-outline);
            border-radius: var(--radius-btn);
        }

        :focus:not(:focus-visible) {
            outline: none;
        }

        .main-header {
            width: 100%;
            max-width: clamp(30rem, 70vw, 60rem);
            margin: 0 auto var(--gap-md) auto;
            flex-shrink: 0;
        }

        .main-header h1 {
            font-size: var(--font-size-xxl);
            font-weight: 700;
            color: var(--color-text-on-dark);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            margin: 0 auto;
            animation: fadeInScreen 0.5s ease-out forwards;
            flex-grow: 1;
            min-height: 0;
        }

        .screen.active {
            display: flex;
        }

        #game-board-screen {
            justify-content: space-between;
        }

        .screen-panel {
            width: 100%;
            max-width: clamp(25rem, 60vw, 40rem);
            padding: var(--padding-lg);
            background-color: var(--color-panel);
            border-radius: var(--radius-panel);
            box-shadow: 0 8px 30px var(--shadow-dark);
            color: var(--color-text-on-light);
        }

        @keyframes fadeInScreen {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #start-screen h2,
        #end-screen h2 {
            font-size: var(--font-size-xl);
            margin-bottom: var(--gap-md);
        }

        #start-screen p,
        .stats .stats-item {
            font-size: var(--font-size-md);
            line-height: 1.6;
            margin-bottom: var(--gap-sm);
        }

        .input-group {
            margin: var(--gap-md) auto;
            width: 100%;
            max-width: clamp(18rem, 80%, 25rem);
        }

        .input-group label,
        .layout-selector legend {
            margin-bottom: var(--gap-sm);
            font-weight: 500;
            font-size: var(--font-size-md);
            color: var(--color-text-on-light);
        }

        .input-group input {
            width: 100%;
            padding: var(--gap-sm) var(--gap-md);
            border-radius: var(--radius-btn);
            border: 2px solid rgba(0, 0, 0, 0.1);
            font-size: var(--font-size-md);
            color: var(--color-text-on-light);
            background-color: rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }

        .input-group input:focus {
            background-color: #759e5618;
            border-color: var(--color-secondary);
        }

        .input-group input.invalid {
            border-color: var(--color-error);
            box-shadow: 0 0 0 3px var(--error-glow);
        }

        .layout-selector {
            margin: var(--gap-md) auto;
            max-width: clamp(18rem, 80%, 25rem);
        }

        .layout-options {
            display: flex;
            justify-content: center;
            gap: var(--gap-sm);
            background-color: #79745321;
            padding: var(--gap-sm);
            border-radius: var(--radius-btn);
        }

        .layout-options input {
            display: none;
        }

        .layout-options label {
            padding: var(--gap-sm) var(--gap-md);
            border-radius: var(--radius-inner);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: var(--font-size-md);
            color: var(--color-primary);
        }

        .layout-options input:checked+label {
            background-color: var(--color-background);
            color: var(--color-text-on-dark);
            box-shadow: 0 2px 8px var(--shadow-subtle) inset;
        }

        .start-buttons,
        .game-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: var(--gap-md);
            margin-top: var(--gap-md);
            flex-shrink: 0;
        }

        .player-rank {
            font-weight: bold;
            color: var(--color-secondary);
            margin-bottom: var(--gap-md);
            font-size: var(--font-size-lg);
        }

        .game-info-panel {
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            gap: var(--gap-sm) var(--gap-md);
            width: 100%;
            max-width: clamp(30rem, 90vw, 60rem);
            margin: 0 auto;
            padding: var(--padding-md);
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--color-text-on-dark);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-panel);
            box-shadow: 0 4px 16px var(--shadow-dark);
            flex-shrink: 0;
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: var(--gap-sm);
            font-size: var(--font-size-lg);
            font-weight: 600;
        }

        .info-item svg {
            width: clamp(24px, 3vmin, 30px);
            height: clamp(24px, 3vmin, 30px);
            stroke: var(--color-accent);
        }

        .memory-game-board {
            display: grid;
            width: 100%;
            perspective: 1500px;
            margin: var(--gap-md) auto;
            min-height: 0;
        }

        .layout--4x4 {
            grid-template-columns: repeat(4, 1fr);
            /* clamp(min, ideal, max)
      - Mínimo de 320px para telas muito pequenas.
      - Ideal de 90vw para ocupar bem o espaço.
      - Máximo de 65vh para não ficar gigante em telas wide-screen,
        um valor mais generoso que os 50vh originais.
    */
            max-width: clamp(500px, 90vw, 53vh);
            gap: var(--gap-sm);
        }

        .layout--8x2 {
            grid-template-columns: repeat(8, 1fr);
            max-width: 90vw;
            max-height: 45vh;
            gap: var(--gap-sm);
        }

        /* ================================================= */
        /* --- APRIMORAMENTO PARA TELAS DE ALTA RESOLUÇÃO --- */
        /* ================================================= */

        @media (min-width: 1750px) {
            .layout--4x4 {
                /* Para telas muito largas, aumentamos o limite de altura (vh)
           permitindo que o tabuleiro cresça mais horizontalmente.*/
                max-width: clamp(300px, 90vw, 53vh);
                gap: var(--gap-sm-maior);
            }
        }

        /* Aplica estas regras apenas quando a largura da tela for de 2560px ou mais (monitores QHD, 4K, etc.) */
        @media (min-width: 2560px) {
            .layout--4x4 {
                /* Para telas muito largas, aumentamos o limite de altura (vh)
           permitindo que o tabuleiro cresça mais horizontalmente.*/
                max-width: clamp(400px, 90vw, 53vh);
                gap: var(--gap-sm-maior);
            }
        }

        @media (min-width: 3500px) {
            .layout--4x4 {
                /* Para telas muito largas, aumentamos o limite de altura (vh)
           permitindo que o tabuleiro cresça mais horizontalmente.*/
                max-width: clamp(400px, 90vw, 60vh);
            }
        }

        @media (max-aspect-ratio: 1/1) {
            .layout--8x2 {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .card {
            background-color: transparent;
            width: 100%;
            aspect-ratio: 1 / 1.35;
            cursor: pointer;
            transform-style: preserve-3d;
            opacity: 0;
            animation: dealCard 0.5s ease-out forwards;
            border-radius: var(--radius-card);
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform var(--flip-duration), box-shadow 0.3s;
            background-color: #fff;
            padding: var(--padding-card);
            border-radius: var(--radius-card);
            box-shadow: 0 4px 12px var(--shadow-medium);
            will-change: transform;
        }

        @keyframes dealCard {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.9);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .card:not(.flipped):not(.matched):hover .card-inner {
            box-shadow: 0 8px 24px var(--shadow-dark);
            transform: translateY(-5px);
        }

        .card.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            inset: var(--padding-card);
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border-radius: var(--radius-inner);
        }

        .card-face img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .card-face--front {
            transform: rotateY(180deg);
        }

        .card.wrong .card-inner {
            animation: shakeWrong 0.5s ease-in-out, glowWrong 0.5s ease-in-out;
        }

        .card.correct .card-inner {
            animation: pulseCorrect 0.6s ease-out;
        }

        .card.matched {
            cursor: default;
        }

        .card.matched .card-inner {
            box-shadow: 0 0 16px 4px var(--success-glow);
            transform: rotateY(180deg) scale(1.02);
        }

        .card:focus-visible .card-inner {
            box-shadow: 0 0 16px 6px var(--color-focus-outline);
        }

        @keyframes shakeWrong {

            0%,
            100% {
                transform: rotateY(180deg) translateX(0);
            }

            20%,
            60% {
                transform: rotateY(180deg) translateX(-8px) rotate(-3deg);
            }

            40%,
            80% {
                transform: rotateY(180deg) translateX(8px) rotate(3deg);
            }
        }

        @keyframes pulseCorrect {

            0%,
            100% {
                transform: rotateY(180deg) scale(1);
                box-shadow: 0 4px 12px var(--shadow-medium);
            }

            50% {
                transform: rotateY(180deg) scale(1.05);
                box-shadow: 0 0 12px 4px var(--success-glow);
            }
        }

        @keyframes glowWrong {

            0%,
            100% {
                box-shadow: 0 4px 12px var(--shadow-medium);
            }

            50% {
                box-shadow: 0 0 12px 4px var(--error-glow);
            }
        }

        .button {
            border: 2px solid transparent;
            padding: var(--gap-sm) var(--padding-lg);
            font-size: var(--font-size-md);
            font-weight: 600;
            border-radius: var(--radius-btn);
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px var(--shadow-subtle);
            letter-spacing: 0.5px;
            min-width: clamp(10rem, 25vmin, 15rem);
        }

        .button:hover {
            box-shadow: 0 4px 12px var(--shadow-medium);
            transform: translateY(-3px);
        }

        .button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 4px var(--shadow-subtle);
        }

        .button.primary {
            background-color: var(--color-secondary);
            color: white;
        }

        .button.primary:hover {
            background-color: hsl(90, 31%, 48%);
        }

        .button.secondary {
            background-color: transparent;
            color: var(--color-secondary);
            border-color: var(--color-secondary);
        }

        .button.secondary:hover {
            background-color: var(--color-secondary);
            color: white;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.6);
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .modal-overlay.active {
            display: flex;
            opacity: 1;
        }

        .modal-content {
            background-color: var(--color-panel);
            color: var(--color-text-on-light);
            padding: var(--padding-lg);
            border-radius: var(--radius-panel);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            max-width: 90%;
            width: clamp(25rem, 70vw, 35rem);
            transform: scale(0.95);
            transition: transform 0.3s ease;
            position: relative;
        }

        .modal-overlay.active .modal-content {
            transform: scale(1);
        }

        .modal-close-button {
            position: absolute;
            top: var(--gap-sm);
            right: var(--gap-md);
            background: none;
            border: none;
            font-size: var(--font-size-xl);
            cursor: pointer;
            color: var(--color-text-on-light);
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .modal-close-button:hover {
            opacity: 1;
        }

        .leaderboard {
            list-style-type: none;
        }

        .leaderboard li {
            display: flex;
            justify-content: space-between;
            padding: var(--gap-md) var(--gap-sm);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            font-size: var(--font-size-md);
        }

        .leaderboard li:last-child {
            border-bottom: none;
        }

        .leaderboard .score-name {
            font-weight: 500;
        }

        .leaderboard .score-value {
            font-weight: 700;
            color: var(--color-secondary);
        }

        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .combo-indicator {
            position: fixed;
            top: 15%;
            left: 50%;
            transform: translateX(-50%) scale(0);
            padding: var(--gap-md) var(--padding-md);
            background: var(--color-secondary);
            color: white;
            font-size: var(--font-size-xl);
            font-weight: 800;
            border-radius: var(--radius-panel);
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
        }

        .combo-indicator.active {
            animation: comboAnimation 1.5s ease-out forwards;
        }

        @keyframes comboAnimation {
            0% {
                transform: translateX(-50%) scale(0);
                opacity: 0;
            }

            20% {
                transform: translateX(-50%) scale(1.1);
                opacity: 1;
            }

            40% {
                transform: translateX(-50%) scale(1);
                opacity: 1;
            }

            80% {
                transform: translateX(-50%) scale(1);
                opacity: 1;
            }

            100% {
                transform: translateX(-50%) scale(0.8);
                opacity: 0;
            }
        }
    </style>
</head>

<body>
    <canvas id="particle-canvas"></canvas>

    <header class="main-header">
        <h1>LM Advogados - Jogo da Memória</h1>
    </header>

    <section id="start-screen" class="screen active">
        <div class="screen-panel">
            <h2>Bem-vindo!</h2>
            <p>Encontre os pares para marcar pontos. Seja rápido e erre o mínimo para entrar no ranking!</p>

            <div class="input-group">
                <label for="player-name">Digite seu nome para o ranking:</label>
                <input type="text" id="player-name" maxlength="15" placeholder="Seu Nome" required>
            </div>

            <fieldset class="layout-selector">
                <legend>Escolha o formato do tabuleiro:</legend>
                <div class="layout-options">
                    <input type="radio" id="layout-4x4" name="layout" value="4x4" checked>
                    <label for="layout-4x4">4 x 4</label>
                    <input type="radio" id="layout-8x2" name="layout" value="8x2">
                    <label for="layout-8x2">8 x 2</label>
                </div>
            </fieldset>

            <div class="start-buttons">
                <button id="start-game-button" class="button primary">Iniciar Jogo</button>
                <button id="show-scores-button" class="button secondary">Recordes</button>
            </div>
        </div>
    </section>

    <main id="game-board-screen" class="screen">
        <div class="game-info-panel">
            <div class="info-item" title="Tempo">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke-width="1.5">
                    <path stroke="currentColor" d="M5 22h14" />
                    <path stroke="currentColor" d="M5 2h14" />
                    <path stroke="currentColor"
                        d="M17 22v-4.172a2 2 0 0 0-.586-1.414L12 12l-4.414 4.414A2 2 0 0 0 7 17.828V22" />
                    <path stroke="currentColor"
                        d="M7 2v4.172a2 2 0 0 0 .586 1.414L12 12l4.414-4.414A2 2 0 0 0 17 6.172V2" />
                </svg>
                <span id="time-display">00:00</span>
            </div>
            <div class="info-item" title="Tentativas">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path stroke="currentColor" d="M21 12a9 9 0 1 1-2.8-6.3L21 8" />
                    <path stroke="currentColor" d="M17 4v4h4" />
                </svg>
                <span id="attempts-display">0</span>
            </div>
            <div class="info-item" title="Pontos">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"
                    stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <polygon
                        points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2">
                    </polygon>
                </svg>
                <span id="score-display">0</span>
            </div>
        </div>
        <div id="memory-game-board" class="memory-game-board" role="grid"></div>
        <div class="game-controls">
            <button id="restart-game-button" class="button secondary">Reiniciar Jogo</button>
            <button id="main-menu-button-game" class="button primary">Menu Principal</button>
        </div>
    </main>

    <section id="end-screen" class="screen">
        <div class="screen-panel">
            <h2>Parabéns, <span id="end-player-name">Jogador</span>!</h2>
            <p class="game-message">Você encontrou todos os pares!</p>
            <p class="player-rank" id="player-rank"></p>
            <div class="stats">
                <p class="stats-item">Tempo Final: <strong id="final-time">00:00</strong></p>
                <p class="stats-item">Tentativas: <strong id="final-attempts">0</strong></p>
                <p class="stats-item">Maior Combo: <strong id="final-combo">x0</strong></p>
                <p class="stats-item">Pontuação Final: <strong id="final-score">0</strong></p>
            </div>
            <div class="game-controls">
                <button id="play-again-button" class="button primary">Jogar Novamente</button>
                <button id="main-menu-button-end" class="button secondary">Menu Principal</button>
            </div>
        </div>
    </section>

    <div id="highscore-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="modal-close-button" class="modal-close-button" aria-label="Fechar modal">&times;</button>
            <h2>Ranking de Pontuações</h2>
            <ol id="leaderboard" class="leaderboard"></ol>
        </div>
    </div>

    <div id="combo-indicator" class="combo-indicator"></div>
    <div id="sr-announcements" class="visually-hidden" aria-live="assertive" aria-atomic="true"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const ui = {
                screens: { start: document.getElementById('start-screen'), game: document.getElementById('game-board-screen'), end: document.getElementById('end-screen') },
                buttons: { start: document.getElementById('start-game-button'), restart: document.getElementById('restart-game-button'), playAgain: document.getElementById('play-again-button'), mainMenuGame: document.getElementById('main-menu-button-game'), mainMenuEnd: document.getElementById('main-menu-button-end'), showScores: document.getElementById('show-scores-button'), closeModal: document.getElementById('modal-close-button'), },
                modal: { overlay: document.getElementById('highscore-modal'), leaderboard: document.getElementById('leaderboard') },
                inputs: { playerName: document.getElementById('player-name') },
                game: { board: document.getElementById('memory-game-board'), time: document.getElementById('time-display'), attempts: document.getElementById('attempts-display'), score: document.getElementById('score-display') },
                endScreen: { playerName: document.getElementById('end-player-name'), rank: document.getElementById('player-rank'), finalTime: document.getElementById('final-time'), finalAttempts: document.getElementById('final-attempts'), finalCombo: document.getElementById('final-combo'), finalScore: document.getElementById('final-score'), },
                feedback: { combo: document.getElementById('combo-indicator'), announcer: document.getElementById('sr-announcements') }
            };

            const PAIRS_PER_GAME = 8;
            const BASE_SCORE_PER_MATCH = 500;
            const COMBO_BONUS = 100;
            const TIME_PENALTY_PER_SECOND = 10;
            const ATTEMPT_PENALTY = 5;

            const ALL_PAIRS_DATA = Array.from({ length: 28 }, (_, i) => {
                const id = i + 1;
                return {
                    pairKey: `par${id}`,
                    partA: {
                        uniqueId: id * 2 - 1,
                        imageFront: `assets/images/cartas_memoria_${id}-A.png`,
                        altText: `Regra ${id}A`
                    },
                    partB: {
                        uniqueId: id * 2,
                        imageFront: `assets/images/cartas_memoria_${id}-B.png`,
                        altText: `Regra ${id}B`
                    }
                };
            });

            let state = {};
            let audioCtx;
            const sounds = { flip: null, match: null, mismatch: null, win: null };

            function setupAudio() {
                if (audioCtx) return;
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

                    sounds.flip = () => {
                        if (!audioCtx) return;
                        const bufferSize = audioCtx.sampleRate * 0.1;
                        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                        const output = buffer.getChannelData(0);
                        for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; }
                        const whiteNoise = audioCtx.createBufferSource();
                        whiteNoise.buffer = buffer;
                        const filter = audioCtx.createBiquadFilter();
                        filter.type = 'bandpass';
                        filter.frequency.setValueAtTime(1500, audioCtx.currentTime);
                        filter.Q.setValueAtTime(2, audioCtx.currentTime);
                        const gain = audioCtx.createGain();
                        gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                        whiteNoise.connect(filter).connect(gain).connect(audioCtx.destination);
                        whiteNoise.start();
                        whiteNoise.stop(audioCtx.currentTime + 0.1);
                    };

                    sounds.mismatch = () => {
                        if (!audioCtx) return;
                        const osc = audioCtx.createOscillator();
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                        const gain = audioCtx.createGain();
                        gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                        osc.connect(gain).connect(audioCtx.destination);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.15);
                    };

                    sounds.match = () => {
                        if (!audioCtx) return;
                        const notes = [[523.25, 0.2, 0], [659.25, 0.3, 0.05]];
                        notes.forEach(([freq, duration, delay]) => {
                            const osc = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            osc.type = 'sine';
                            osc.frequency.setValueAtTime(freq, audioCtx.currentTime + delay);
                            gain.gain.setValueAtTime(0.2, audioCtx.currentTime + delay);
                            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + delay + duration);
                            osc.connect(gain).connect(audioCtx.destination);
                            osc.start(audioCtx.currentTime + delay);
                            osc.stop(audioCtx.currentTime + delay + duration);
                        });
                    };

                    sounds.win = () => {
                        if (!audioCtx) return;
                        const notes = [[523.25, 0.1, 0], [659.25, 0.1, 0.1], [783.99, 0.1, 0.2], [1046.50, 0.2, 0.3]];
                        notes.forEach(([freq, duration, delay]) => {
                            const osc = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            osc.type = 'sine';
                            osc.frequency.setValueAtTime(freq, audioCtx.currentTime + delay);
                            gain.gain.setValueAtTime(0.2, audioCtx.currentTime + delay);
                            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + delay + duration);
                            osc.connect(gain).connect(audioCtx.destination);
                            osc.start(audioCtx.currentTime + delay);
                            osc.stop(audioCtx.currentTime + delay + duration);
                        });
                    };

                } catch (e) { console.error("Web Audio API is not supported in this browser"); }
            }

            function setupParticleCanvas() {
                const canvas = document.getElementById('particle-canvas');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                let particles = [];
                const resizeCanvas = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
                const createParticles = () => {
                    particles = [];
                    const particleCount = Math.floor((canvas.width * canvas.height) / 20000);
                    for (let i = 0; i < particleCount; i++) {
                        particles.push({
                            x: Math.random() * canvas.width, y: Math.random() * canvas.height,
                            radius: Math.random() * 1.5 + 0.5, speedX: (Math.random() - 0.5) * 0.3,
                            speedY: (Math.random() - 0.5) * 0.3, opacity: Math.random() * 0.5 + 0.2,
                        });
                    }
                };
                const animateParticles = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    particles.forEach(p => {
                        p.x += p.speedX; p.y += p.speedY;
                        if (p.x < 0 || p.x > canvas.width) p.speedX *= -1;
                        if (p.y < 0 || p.y > canvas.height) p.speedY *= -1;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(211, 204, 158, ${p.opacity})`;
                        ctx.fill();
                    });
                    requestAnimationFrame(animateParticles);
                };
                window.addEventListener('resize', () => { resizeCanvas(); createParticles(); });
                resizeCanvas();
                createParticles();
                animateParticles();
            }

            function updateFavicon(status = 'default') {
                const canvas = document.createElement('canvas');
                canvas.width = 32; canvas.height = 32;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#232b56';
                ctx.fillRect(0, 0, 32, 32);
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                if (status === 'win') {
                    ctx.fillStyle = '#759e56';
                    ctx.font = 'bold 24px sans-serif';
                    ctx.fillText('✓', 16, 18);
                } else {
                    ctx.fillStyle = '#d3cc9e';
                    ctx.font = 'bold 16px "Inter", sans-serif';
                    ctx.fillText('LM', 16, 16);
                }
                const link = document.querySelector("link[rel~='icon']");
                if (link) {
                    link.href = canvas.toDataURL('image/png');
                }
            }

            const resetState = () => {
                const layout = document.querySelector('input[name="layout"]:checked')?.value || '4x4';
                state = { flippedCards: [], matchedPairs: 0, lockBoard: false, gameStarted: false, timerInterval: null, seconds: 0, attempts: 0, combo: 0, maxCombo: 0, score: 0, playerName: state.playerName || "Jogador", layout };
            };

            const shuffleArray = arr => arr.sort(() => Math.random() - 0.5);

            const formatTime = s => `${String(Math.floor(s / 60)).padStart(2, '0')}:${String(s % 60).padStart(2, '0')}`;

            const showScreen = screen => { Object.values(ui.screens).forEach(s => s.classList.remove('active')); screen.classList.add('active'); };

            const announce = msg => { ui.feedback.announcer.textContent = msg; };

            function updateStats() {
                ui.game.time.textContent = formatTime(state.seconds);
                ui.game.attempts.textContent = state.attempts;
                ui.game.score.textContent = state.score;
            }

            function startTimer() {
                if (state.timerInterval) clearInterval(state.timerInterval);
                state.timerInterval = setInterval(() => { state.seconds++; updateStats(); }, 1000);
            }

            function createBoard() {
                const board = ui.game.board;
                board.innerHTML = '';
                board.className = 'memory-game-board';
                board.classList.add(state.layout === '4x4' ? 'layout--4x4' : 'layout--8x2');

                const selectedPairs = shuffleArray([...ALL_PAIRS_DATA]).slice(0, PAIRS_PER_GAME);

                const gameCards = shuffleArray(
                    selectedPairs.flatMap(p => [
                        { image: p.partA.imageFront, key: p.pairKey, type: 'A', alt: p.partA.altText },
                        { image: p.partB.imageFront, key: p.pairKey, type: 'B', alt: p.partB.altText }
                    ])
                );

                const fragment = document.createDocumentFragment();
                gameCards.forEach((cardData, index) => {
                    const cardEl = document.createElement('div');
                    cardEl.classList.add('card');
                    cardEl.dataset.key = cardData.key;
                    cardEl.style.animationDelay = `${index * 50}ms`;
                    cardEl.setAttribute('tabindex', '0');

                    // --- REFORMULAÇÃO DA LÓGICA DO VERSO DAS CARTAS ---
                    // Carta A -> Verso Azul Escuro (Capa 2)
                    // Carta B -> Verso Azul Claro (Capa 1)
                    const backImageSrc = cardData.type === 'A'
                        ? 'assets/images/cartas_memoria-CAPA-2.png'
                        : 'assets/images/cartas_memoria-CAPA-1.png';

                    cardEl.innerHTML = `
                    <div class="card-inner">
                        <div class="card-face card-face--back">
                            <img src="${backImageSrc}" alt="Verso da carta">
                        </div>
                        <div class="card-face card-face--front">
                            <img src="${cardData.image}" alt="${cardData.alt}">
                        </div>
                    </div>`;
                    fragment.appendChild(cardEl);
                });
                board.appendChild(fragment);
            }

            function handleCardInteraction(event) {
                const card = event.target.closest('.card');
                if (!card || state.lockBoard || card.classList.contains('flipped') || card.classList.contains('matched')) return;
                if (!state.gameStarted) { state.gameStarted = true; startTimer(); }

                sounds.flip();
                card.classList.add('flipped');
                state.flippedCards.push(card);

                if (state.flippedCards.length === 2) {
                    state.lockBoard = true;
                    state.attempts++;
                    updateStats();
                    checkForMatch();
                }
            }

            function checkForMatch() {
                const [cardOne, cardTwo] = state.flippedCards;
                const isMatch = cardOne.dataset.key === cardTwo.dataset.key;

                cardOne.classList.add(isMatch ? 'correct' : 'wrong');
                cardTwo.classList.add(isMatch ? 'correct' : 'wrong');

                setTimeout(() => {
                    isMatch ? handleCorrectMatch(cardOne, cardTwo) : handleWrongMatch(cardOne, cardTwo);
                }, isMatch ? 600 : 1000);
            }

            function handleCorrectMatch(cardOne, cardTwo) {
                sounds.match();
                announce("Par encontrado!");
                state.combo++;
                state.maxCombo = Math.max(state.maxCombo, state.combo);
                if (state.combo > 1) {
                    ui.feedback.combo.textContent = `COMBO x${state.combo}!`;
                    ui.feedback.combo.classList.add('active');
                    setTimeout(() => ui.feedback.combo.classList.remove('active'), 1500);
                }
                state.score += BASE_SCORE_PER_MATCH + (state.combo * COMBO_BONUS);
                updateStats();

                cardOne.classList.remove('correct');
                cardTwo.classList.remove('correct');
                cardOne.classList.add('matched');
                cardTwo.classList.add('matched');
                cardOne.setAttribute('tabindex', '-1');
                cardTwo.setAttribute('tabindex', '-1');
                state.matchedPairs++;

                resetTurn();
                if (state.matchedPairs === PAIRS_PER_GAME) endGame();
            }

            function handleWrongMatch(cardOne, cardTwo) {
                sounds.mismatch();
                announce("Não é um par.");
                state.combo = 0;

                cardOne.classList.remove('wrong', 'flipped');
                cardTwo.classList.remove('wrong', 'flipped');

                resetTurn();
            }

            const resetTurn = () => { state.flippedCards = []; state.lockBoard = false; };

            function startGame() {
                const playerName = ui.inputs.playerName.value.trim();
                if (!playerName) {
                    ui.inputs.playerName.classList.add('invalid');
                    setTimeout(() => ui.inputs.playerName.classList.remove('invalid'), 2000);
                    ui.inputs.playerName.focus();
                    return;
                }

                resetState();
                state.playerName = playerName;
                updateStats();
                createBoard();
                showScreen(ui.screens.game);
                announce("Jogo iniciado!");
            }

            function endGame() {
                clearInterval(state.timerInterval);
                sounds.win();
                updateFavicon('win');
                if (typeof confetti === 'function') {
                    confetti({ particleCount: 150, spread: 90, origin: { y: 0.6 } });
                }

                const scorePenalty = (state.seconds * TIME_PENALTY_PER_SECOND) + (state.attempts * ATTEMPT_PENALTY);
                const finalScore = Math.max(0, state.score - scorePenalty);

                saveScore(state.playerName, finalScore);

                ui.endScreen.playerName.textContent = state.playerName;
                ui.endScreen.finalTime.textContent = formatTime(state.seconds);
                ui.endScreen.finalAttempts.textContent = state.attempts;
                ui.endScreen.finalCombo.textContent = `x${state.maxCombo}`;
                ui.endScreen.finalScore.textContent = finalScore;
                displayPlayerRank(state.playerName, finalScore);

                setTimeout(() => showScreen(ui.screens.end), 800);
            }

            function showMainMenu() {
                clearInterval(state.timerInterval);
                const currentName = state.playerName;
                resetState();
                state.playerName = currentName;
                ui.inputs.playerName.value = state.playerName !== "Jogador" ? state.playerName : "";
                updateFavicon('default');
                showScreen(ui.screens.start);
            }

            const getScores = () => JSON.parse(localStorage.getItem('lmwinScores')) || [];

            function saveScore(name, score) {
                const scores = getScores();
                scores.push({ name, score });
                scores.sort((a, b) => b.score - a.score);
                localStorage.setItem('lmwinScores', JSON.stringify(scores.slice(0, 10)));
            }

            function displayLeaderboard() {
                const scores = getScores();
                ui.modal.leaderboard.innerHTML = scores.length
                    ? scores.map((s, i) => `<li><span>#${i + 1} <span class="score-name">${s.name}</span></span> <span class="score-value">${s.score} pts</span></li>`).join('')
                    : '<li>Nenhum recorde ainda. Seja o primeiro!</li>';
            }

            function displayPlayerRank(name, score) {
                const scores = getScores();
                const rank = scores.findIndex(s => s.name === name && s.score === score);
                ui.endScreen.rank.textContent = rank !== -1 ? `Sua Posição no Ranking: #${rank + 1}` : "Sua pontuação não entrou no Top 10.";
            }

            ui.buttons.start.addEventListener('click', startGame);
            [ui.buttons.restart, ui.buttons.playAgain].forEach(btn => btn.addEventListener('click', startGame));
            [ui.buttons.mainMenuGame, ui.buttons.mainMenuEnd].forEach(btn => btn.addEventListener('click', showMainMenu));

            ui.game.board.addEventListener('click', handleCardInteraction);
            ui.game.board.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    handleCardInteraction({ target: document.activeElement });
                }
            });

            document.querySelectorAll('.layout-options label').forEach(label => {
                label.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter' || event.key === ' ') {
                        event.preventDefault();
                        document.getElementById(label.getAttribute('for')).click();
                    }
                });
            });

            let lastFocusedElement;
            ui.buttons.showScores.addEventListener('click', () => {
                lastFocusedElement = document.activeElement;
                displayLeaderboard();
                ui.modal.overlay.classList.add('active');
                ui.buttons.closeModal.focus();
            });

            const closeModal = () => {
                ui.modal.overlay.classList.remove('active');
                if (lastFocusedElement) {
                    lastFocusedElement.focus();
                }
            };

            ui.buttons.closeModal.addEventListener('click', closeModal);
            ui.modal.overlay.addEventListener('click', e => { if (e.target === e.currentTarget) closeModal(); });

            document.addEventListener('keydown', e => {
                const isModalOpen = ui.modal.overlay.classList.contains('active');
                const isGameScreen = ui.screens.game.classList.contains('active');
                const isEndScreen = ui.screens.end.classList.contains('active');
                const isBackKey = e.key === 'Escape';

                if (isBackKey) {
                    e.preventDefault();
                    if (isModalOpen) closeModal();
                    else if (isGameScreen) ui.buttons.mainMenuGame.click();
                    else if (isEndScreen) ui.buttons.mainMenuEnd.click();
                }
            });

            document.addEventListener('click', setupAudio, { once: true });

            resetState();
            ui.inputs.playerName.value = "";
            updateFavicon('default');
            setupParticleCanvas();
            showScreen(ui.screens.start);
        });
    </script>
</body>

</html>