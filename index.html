<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LM Advogados - Jogo da Memória</title>
    <link rel="icon" href="">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/canvas-confetti/1.9.2/confetti.browser.min.js"></script>
    <style>
        :root {
            --color-primary: #232b56;
            --color-secondary: #759e56;
            --color-accent: #d3cc9e;
            --color-background: var(--color-primary);
            --color-panel: var(--color-accent);
            --color-text-on-dark: var(--color-accent);
            --color-text-on-light: var(--color-primary);
            --color-error: #a83232;
            --color-focus-outline: #232b56;
            --success-glow: rgba(117, 158, 86, 0.7);
            --error-glow: rgba(168, 50, 50, 0.6);
            --shadow-subtle: rgba(0, 0, 0, 0.08);
            --shadow-medium: rgba(0, 0, 0, 0.12);
            --shadow-dark: rgba(0, 0, 0, 0.16);
            --radius-panel: clamp(16px, 2vmin, 24px);
            --radius-btn: clamp(10px, 1.2vmin, 14px);
            --radius-card: clamp(8px, 1vmin, 12px);
            --radius-inner: clamp(6px, 0.8vmin, 10px);
            --padding-card: clamp(6px, 1vmin, 6px);
            --padding-md: clamp(1rem, 2vmin, 2rem);
            --padding-lg: clamp(1.5rem, 3vmin, 3rem);
            --gap-sm: clamp(0.5rem, 1.5vmin, 1rem);
            --gap-md: clamp(1rem, 2.5vmin, 1.5rem);
            --font-family: 'Inter', sans-serif;
            --font-size-md: clamp(1rem, 2.2vmin, 1.15rem);
            --font-size-lg: clamp(1.2rem, 2.8vmin, 1.5rem);
            --font-size-xl: clamp(1.5rem, 3.5vmin, 2.25rem);
            --font-size-xxl: clamp(2rem, 4.5vmin, 3rem);
            --flip-duration: 0.5s;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--color-background);
            color: var(--color-text-on-dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            max-height: 100vh;
            padding: var(--gap-md);
            text-align: center;
            overflow: hidden;
            position: relative;
        }

        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(35, 43, 86, 0) 0%, rgba(35, 43, 86, 1) 100%);
            z-index: -1;
        }

        :focus-visible {
            outline: 2px solid var(--color-focus-outline);
            box-shadow: 0 0 10px var(--color-focus-outline);
            border-radius: var(--radius-btn);
        }

        :focus:not(:focus-visible) {
            outline: none;
        }

        .main-header {
            width: 100%;
            max-width: clamp(30rem, 70vw, 60rem);
            margin: 0 auto var(--gap-md) auto;
            flex-shrink: 0;
        }

        .main-header h1 {
            font-size: var(--font-size-xxl);
            font-weight: 700;
            color: var(--color-text-on-dark);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            margin: 0 auto;
            animation: fadeInScreen 0.5s ease-out forwards;
            flex-grow: 1;
            min-height: 0;
        }

        .screen.active {
            display: flex;
        }

        #game-board-screen {
            justify-content: center;
        }

        .screen-panel {
            width: 100%;
            max-width: clamp(25rem, 60vw, 40rem);
            padding: var(--padding-lg);
            background-color: var(--color-panel);
            border-radius: var(--radius-panel);
            box-shadow: 0 8px 30px var(--shadow-dark);
            color: var(--color-text-on-light);
        }

        @keyframes fadeInScreen {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #start-screen h2,
        #end-screen h2 {
            font-size: var(--font-size-xl);
            margin-bottom: var(--gap-md);
        }

        #start-screen p,
        .stats .stats-item {
            font-size: var(--font-size-md);
            line-height: 1.6;
            margin-bottom: var(--gap-sm);
        }

        .input-group {
            margin: var(--gap-md) auto;
            width: 100%;
            max-width: clamp(18rem, 80%, 25rem);
        }

        .input-group label,
        .layout-selector legend {
            margin-bottom: var(--gap-sm);
            font-weight: 500;
            font-size: var(--font-size-md);
            color: var(--color-text-on-light);
        }

        .input-group input {
            width: 100%;
            padding: var(--gap-sm) var(--gap-md);
            border-radius: var(--radius-btn);
            border: 2px solid rgba(0, 0, 0, 0.1);
            font-size: var(--font-size-md);
            color: var(--color-text-on-light);
            background-color: rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }

        .input-group input:focus {
            background-color: #759e5618;
            border-color: var(--color-secondary);
        }

        .input-group input.invalid {
            border-color: var(--color-error);
            box-shadow: 0 0 0 3px var(--error-glow);
        }

        .layout-selector {
            margin: var(--gap-md) auto;
            max-width: clamp(18rem, 80%, 25rem);
        }

        .layout-options {
            display: flex;
            justify-content: center;
            gap: var(--gap-sm);
            background-color: #79745321;
            padding: var(--gap-sm);
            border-radius: var(--radius-btn);
        }

        .layout-options input {
            display: none;
        }

        .layout-options label {
            padding: var(--gap-sm) var(--gap-md);
            border-radius: var(--radius-inner);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: var(--font-size-md);
            color: var(--color-primary);
        }

        .layout-options input:checked+label {
            background-color: var(--color-background);
            color: var(--color-text-on-dark);
            box-shadow: 0 2px 8px var(--shadow-subtle) inset;
        }

        .start-buttons,
        .game-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: var(--gap-md);
            margin-top: var(--gap-md);
            flex-shrink: 0;
        }

        .player-rank {
            font-weight: bold;
            color: var(--color-secondary);
            margin-bottom: var(--gap-md);
            font-size: var(--font-size-lg);
        }

        .game-info-panel {
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: nowrap;
            gap: var(--gap-sm) var(--gap-md);
            width: 100%;
            max-width: clamp(30rem, 90vw, 60rem);
            margin: 0 auto var(--gap-md) auto;
            padding: var(--padding-md);
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--color-text-on-dark);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-panel);
            box-shadow: 0 4px 16px var(--shadow-dark);
            flex-shrink: 0;
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: var(--gap-sm);
            font-size: var(--font-size-lg);
            font-weight: 600;
        }

        .info-item svg {
            width: clamp(24px, 3vmin, 30px);
            height: clamp(24px, 3vmin, 30px);
            stroke: var(--color-accent);
        }

        .memory-game-board {
            display: grid;
            width: 100%;
            perspective: 1500px;
            margin: 0 auto;
            min-height: 0;
        }

        .card {
            background-color: transparent;
            width: 100%;
            aspect-ratio: 1 / 1.35;
            cursor: pointer;
            transform-style: preserve-3d;
            opacity: 0;
            animation: dealCard 0.5s ease-out forwards;
            border-radius: var(--radius-card);
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform var(--flip-duration), box-shadow 0.3s;
            border-radius: var(--radius-card);
            box-shadow: 0 4px 12px var(--shadow-medium);
            will-change: transform;
        }

        @keyframes dealCard {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.9);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .card:not(.flipped):not(.matched):hover .card-inner {
            box-shadow: 0 8px 24px var(--shadow-dark);
            transform: translateY(-5px);
        }

        .card.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            inset: 0;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border-radius: var(--radius-card);
            border-top: 4px solid white;
            border-bottom: 4px solid white;
        }

        .card-face img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: calc(var(--radius-card) - 10px);
        }

        .card-face--front {
            transform: rotateY(180deg);
        }

        .card.wrong .card-inner {
            animation: shakeWrong 0.5s ease-in-out, glowWrong 0.5s ease-in-out;
        }

        .card.correct .card-inner {
            animation: pulseCorrect 0.6s ease-out;
        }

        .card.matched {
            cursor: default;
        }

        .card.matched .card-inner {
            box-shadow: 0 0 16px 4px var(--success-glow);
            transform: rotateY(180deg) scale(1.02);
        }

        .card:focus-visible .card-inner {
            box-shadow: 0 0 16px 6px var(--color-focus-outline);
        }

        @keyframes shakeWrong {

            0%,
            100% {
                transform: rotateY(180deg) translateX(0);
            }

            20%,
            60% {
                transform: rotateY(180deg) translateX(-8px) rotate(-3deg);
            }

            40%,
            80% {
                transform: rotateY(180deg) translateX(8px) rotate(3deg);
            }
        }

        @keyframes pulseCorrect {

            0%,
            100% {
                transform: rotateY(180deg) scale(1);
                box-shadow: 0 4px 12px var(--shadow-medium);
            }

            50% {
                transform: rotateY(180deg) scale(1.05);
                box-shadow: 0 0 12px 4px var(--success-glow);
            }
        }

        @keyframes glowWrong {

            0%,
            100% {
                box-shadow: 0 4px 12px var(--shadow-medium);
            }

            50% {
                box-shadow: 0 0 12px 4px var(--error-glow);
            }
        }

        .button {
            border: 2px solid transparent;
            padding: var(--gap-sm) var(--padding-lg);
            font-size: var(--font-size-md);
            font-weight: 600;
            border-radius: var(--radius-btn);
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px var(--shadow-subtle);
            letter-spacing: 0.5px;
            min-width: clamp(10rem, 25vmin, 15rem);
        }

        .button:hover {
            box-shadow: 0 4px 12px var(--shadow-medium);
            transform: translateY(-3px);
        }

        .button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 4px var(--shadow-subtle);
        }

        .button.primary {
            background-color: var(--color-secondary);
            color: white;
        }

        .button.primary:hover {
            background-color: hsl(90, 31%, 48%);
        }

        .button.secondary {
            background-color: transparent;
            color: var(--color-secondary);
            border-color: var(--color-secondary);
        }

        .button.secondary:hover {
            background-color: var(--color-secondary);
            color: white;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.6);
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .modal-overlay.active {
            display: flex;
            opacity: 1;
        }

        .modal-content {
            background-color: var(--color-panel);
            color: var(--color-text-on-light);
            padding: var(--padding-lg);
            border-radius: var(--radius-panel);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            max-width: 90%;
            width: clamp(25rem, 70vw, 35rem);
            transform: scale(0.95);
            transition: transform 0.3s ease;
            position: relative;
        }

        .modal-overlay.active .modal-content {
            transform: scale(1);
        }

        .modal-close-button {
            position: absolute;
            top: var(--gap-sm);
            right: var(--gap-md);
            background: none;
            border: none;
            font-size: var(--font-size-xl);
            cursor: pointer;
            color: var(--color-text-on-light);
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .modal-close-button:hover {
            opacity: 1;
        }

        .leaderboard {
            list-style-type: none;
        }

        .leaderboard li {
            display: flex;
            justify-content: space-between;
            padding: var(--gap-md) var(--gap-sm);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            font-size: var(--font-size-md);
        }

        .leaderboard li:last-child {
            border-bottom: none;
        }

        .leaderboard .score-name {
            font-weight: 500;
        }

        .leaderboard .score-value {
            font-weight: 700;
            color: var(--color-secondary);
        }

        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .combo-indicator {
            position: fixed;
            top: 15%;
            left: 50%;
            transform: translateX(-50%) scale(0);
            padding: var(--gap-md) var(--padding-md);
            background: var(--color-secondary);
            color: white;
            font-size: var(--font-size-xl);
            font-weight: 800;
            border-radius: var(--radius-panel);
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
        }

        .combo-indicator.active {
            animation: comboAnimation 1.5s ease-out forwards;
        }

        @keyframes comboAnimation {
            0% {
                transform: translateX(-50%) scale(0);
                opacity: 0;
            }

            20% {
                transform: translateX(-50%) scale(1.1);
                opacity: 1;
            }

            40% {
                transform: translateX(-50%) scale(1);
                opacity: 1;
            }

            80% {
                transform: translateX(-50%) scale(1);
                opacity: 1;
            }

            100% {
                transform: translateX(-50%) scale(0.8);
                opacity: 0;
            }
        }

        .hud-button {
            min-width: unset;
            width: clamp(40px, 8vmin, 48px);
            height: clamp(35px, 7vmin, 40px);
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .hud-button svg {
            width: 70%;
            height: 70%;
        }

        .game-info-panel .hud-button:first-of-type {
            margin-left: auto;
        }

        /* =================================================================== */
        /* == INÍCIO: REGRAS DE LAYOUT RESPONSIVO PARA O TABULEIRO DO JOGO == */
        /* =================================================================== */

        /* --- REGRAS GERAIS / BASE (FALLBACK) --- */
        .layout--4x4 {
            grid-template-columns: repeat(4, 1fr);
            max-width: min(90vw, 62vh);
            gap: var(--gap-sm);
        }

        .layout--8x2 {
            grid-template-columns: repeat(8, 1fr);
            max-width: 90vw;
            max-height: 62vh;
            gap: var(--gap-sm);
        }

        /* --- RESOLUÇÃO PARA CELULAR (até 767px de largura) --- */
        @media (max-width: 767px) {
            .layout--4x4 {
                grid-template-columns: repeat(4, 1fr);
                max-width: 95vw;
                gap: calc(var(--gap-sm) * 0.8);
            }

            .layout--8x2 {
                grid-template-columns: repeat(4, 1fr);
                grid-template-rows: repeat(4, 1fr);
                max-width: 95vw;
                max-height: unset;
                gap: calc(var(--gap-sm) * 0.8);
            }
        }

        /* --- RESOLUÇÃO 1280x720 (HD) --- */
        @media (min-width: 1280px) and (max-width: 1919px) {
            .layout--4x4 {
                grid-template-columns: repeat(4, 1fr);
                max-width: 60vh;
                gap: var(--gap-sm);
            }

            .layout--8x2 {
                grid-template-columns: repeat(8, 1fr);
                max-width: 900vh;
                max-height: 900vh;
                gap: var(--gap-sm);
            }
        }

        /* --- RESOLUÇÃO 1920x1080 (Full HD) --- */
        @media (min-width: 1920px) and (max-width: 2559px) {
            .layout--4x4 {
                grid-template-columns: repeat(4, 1fr);
                max-width: 63vh;
                gap: clamp(1rem, 1.5vmin, 1.25rem);
            }

            .layout--8x2 {
                grid-template-columns: repeat(8, 1fr);
                max-width: 900vh;
                max-height: 900vh;
                gap: clamp(1rem, 1.5vmin, 1.25rem);
            }
        }

        /* --- RESOLUÇÃO 2560x1440 (QHD) --- */
        @media (min-width: 2560px) and (max-width: 3839px) {
            .layout--4x4 {
                grid-template-columns: repeat(4, 1fr);
                max-width: 64vh;
                gap: clamp(1.2rem, 1.5vmin, 1.5rem);
            }

            .layout--8x2 {
                grid-template-columns: repeat(8, 1fr);
                max-width: 900vh;
                max-height: 900vh;
                gap: clamp(1.2rem, 1.5vmin, 1.5rem);
            }
        }

        /* --- RESOLUÇÃO 3840x2160 (4K UHD) --- */
        @media (min-width: 3840px) {
            .layout--4x4 {
                grid-template-columns: repeat(4, 1fr);
                max-width: 67vh;
                gap: clamp(1.5rem, 1.5vmin, 2rem);
            }

            .layout--8x2 {
                grid-template-columns: repeat(8, 1fr);
                max-width: 900vh;
                max-height: 900vh;
                gap: clamp(1.5rem, 1.5vmin, 2rem);
            }
        }

        /* =============================================================== */
        /* == FIM: REGRAS DE LAYOUT RESPONSIVO PARA O TABULEIRO DO JOGO == */
        /* =============================================================== */


        /* =================================================================== */
        /* == INÍCIO: REGRAS RESPONSIVAS PARA PAINÉIS (MENU/FIM DE JOGO) == */
        /* =================================================================== */

        /* --- BASE --- */
        /* Adiciona uma transição suave para a mudança de escala */
        #start-screen .screen-panel,
        #end-screen .screen-panel {
            transform-origin: center;
            transition: transform 0.3s ease-out, max-width 0.3s ease-out;
        }

        /* --- RESOLUÇÃO PARA CELULAR (até 767px) --- */
        @media (max-width: 767px) {

            #start-screen .screen-panel,
            #end-screen .screen-panel {
                max-width: 95vw;
                /* Garante que o painel não ultrapasse a tela */
                padding: var(--padding-md);
                /* Reduz o padding em telas muito pequenas */
                transform: scale(0.95);
                /* Leve redução para caber melhor */
            }
        }

        /* --- RESOLUÇÃO 1920x1080 (Full HD) --- */
        @media (min-width: 1920px) and (max-width: 2559px) {

            #start-screen .screen-panel,
            #end-screen .screen-panel {
                max-width: 45rem;
                transform: scale(1.15);
            }
        }

        /* --- RESOLUÇÃO 2560x1440 (QHD) --- */
        @media (min-width: 2560px) and (max-width: 3839px) {

            #start-screen .screen-panel,
            #end-screen .screen-panel {
                max-width: 50rem;
                transform: scale(1.25);
            }
        }

        /* --- RESOLUÇÃO 3840x2160 (4K UHD) --- */
        @media (min-width: 3840px) {

            #start-screen .screen-panel,
            #end-screen .screen-panel {
                max-width: 60rem;
                transform: scale(1.4);
            }
        }

        /* =============================================================== */
        /* == FIM: REGRAS RESPONSIVAS PARA PAINÉIS (MENU/FIM DE JOGO) == */
        /* =============================================================== */
    </style>
</head>

<body>
    <canvas id="particle-canvas"></canvas>

    <header class="main-header">
        <h1>LM Advogados - Jogo da Memória</h1>
    </header>

    <div class="game-info-panel">
        <div class="info-item" title="Tempo">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                stroke-width="1.5">
                <path stroke="currentColor" d="M5 22h14" />
                <path stroke="currentColor" d="M5 2h14" />
                <path stroke="currentColor"
                    d="M17 22v-4.172a2 2 0 0 0-.586-1.414L12 12l-4.414 4.414A2 2 0 0 0 7 17.828V22" />
                <path stroke="currentColor"
                    d="M7 2v4.172a2 2 0 0 0 .586 1.414L12 12l4.414-4.414A2 2 0 0 0 17 6.172V2" />
            </svg>
            <span id="time-display">00:00</span>
        </div>
        <div class="info-item" title="Tentativas">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="currentColor" d="M21 12a9 9 0 1 1-2.8-6.3L21 8" />
                <path stroke="currentColor" d="M17 4v4h4" />
            </svg>
            <span id="attempts-display">0</span>
        </div>
        <div class="info-item" title="Pontos">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"
                stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <polygon
                    points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2">
                </polygon>
            </svg>
            <span id="score-display">0</span>
        </div>
        <button id="restart-game-button" class="button secondary hud-button" title="Reiniciar Jogo"
            aria-label="Reiniciar Jogo">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4" />
                <path d="M4 13a8.1 8.1 0 0 0 15.5 2l-4.5-2.5M20 19v-4h-4" />
            </svg>
        </button>
        <button id="main-menu-button-game" class="button primary hud-button" title="Menu Principal"
            aria-label="Menu Principal">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" />
                <polyline points="9 22 9 12 15 12 15 22" />
            </svg>
        </button>
    </div>

    <section id="start-screen" class="screen active">
        <div class="screen-panel">
            <h2>Bem-vindo!</h2>
            <p>Encontre os pares para marcar pontos. Seja rápido e erre o mínimo para entrar no ranking!</p>
            <div class="input-group">
                <label for="player-name">Digite seu nome para o ranking:</label>
                <input type="text" id="player-name" maxlength="15" placeholder="Seu Nome" required>
            </div>
            <fieldset class="layout-selector">
                <legend>Escolha o formato do tabuleiro:</legend>
                <div class="layout-options">
                    <input type="radio" id="layout-4x4" name="layout" value="4x4" checked>
                    <label for="layout-4x4">4 x 4</label>
                    <input type="radio" id="layout-8x2" name="layout" value="8x2">
                    <label for="layout-8x2">8 x 2</label>
                </div>
            </fieldset>
            <div class="start-buttons">
                <button id="start-game-button" class="button primary">Iniciar Jogo</button>
                <button id="show-scores-button" class="button secondary">Recordes</button>
            </div>
        </div>
    </section>

    <main id="game-board-screen" class="screen">
        <div id="memory-game-board" class="memory-game-board" role="grid"></div>
    </main>

    <section id="end-screen" class="screen">
        <div class="screen-panel">
            <h2>Parabéns, <span id="end-player-name">Jogador</span>!</h2>
            <p class="game-message">Você encontrou todos os pares!</p>
            <p class="player-rank" id="player-rank"></p>
            <div class="stats">
                <p class="stats-item">Tempo Final: <strong id="final-time">00:00</strong></p>
                <p class="stats-item">Tentativas: <strong id="final-attempts">0</strong></p>
                <p class="stats-item">Maior Combo: <strong id="final-combo">x0</strong></p>
                <p class="stats-item">Pontuação Final: <strong id="final-score">0</strong></p>
            </div>
            <div class="game-controls">
                <button id="play-again-button" class="button primary">Jogar Novamente</button>
                <button id="main-menu-button-end" class="button secondary">Menu Principal</button>
            </div>
        </div>
    </section>

    <div id="highscore-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="modal-close-button" class="modal-close-button" aria-label="Fechar modal">&times;</button>
            <h2>Ranking de Pontuações</h2>
            <ol id="leaderboard" class="leaderboard"></ol>
        </div>
    </div>

    <div id="combo-indicator" class="combo-indicator"></div>
    <div id="sr-announcements" class="visually-hidden" aria-live="assertive" aria-atomic="true"></div>

    <script>
        // SEU JAVASCRIPT PERMANECE EXATAMENTE O MESMO
        document.addEventListener('DOMContentLoaded', () => {

            const ui = {
                header: document.querySelector('.main-header'),
                screens: { start: document.getElementById('start-screen'), game: document.getElementById('game-board-screen'), end: document.getElementById('end-screen') },
                buttons: { start: document.getElementById('start-game-button'), restart: document.getElementById('restart-game-button'), playAgain: document.getElementById('play-again-button'), mainMenuGame: document.getElementById('main-menu-button-game'), mainMenuEnd: document.getElementById('main-menu-button-end'), showScores: document.getElementById('show-scores-button'), closeModal: document.getElementById('modal-close-button'), },
                modal: { overlay: document.getElementById('highscore-modal'), leaderboard: document.getElementById('leaderboard') },
                inputs: { playerName: document.getElementById('player-name') },
                game: {
                    hud: document.querySelector('.game-info-panel'),
                    board: document.getElementById('memory-game-board'),
                    time: document.getElementById('time-display'),
                    attempts: document.getElementById('attempts-display'),
                    score: document.getElementById('score-display')
                },
                endScreen: { playerName: document.getElementById('end-player-name'), rank: document.getElementById('player-rank'), finalTime: document.getElementById('final-time'), finalAttempts: document.getElementById('final-attempts'), finalCombo: document.getElementById('final-combo'), finalScore: document.getElementById('final-score'), },
                feedback: { combo: document.getElementById('combo-indicator'), announcer: document.getElementById('sr-announcements') }
            };

            const GAME_CONFIG = {
                PAIRS_PER_GAME: 8,
                BASE_SCORE_PER_MATCH: 500,
                COMBO_BONUS: 100,
                TIME_PENALTY_PER_SECOND: 10,
                ATTEMPT_PENALTY: 5,
                LEADERBOARD_KEY: 'lmwinScores'
            };

            const ALL_PAIRS_DATA = Array.from({ length: 28 }, (_, i) => {
                const id = i + 1;
                return {
                    pairKey: `par${id}`,
                    partA: { uniqueId: id * 2 - 1, imageFront: `assets/images/cartas_memoria_${id}-A.png`, altText: `Regra ${id}A` },
                    partB: { uniqueId: id * 2, imageFront: `assets/images/cartas_memoria_${id}-B.png`, altText: `Regra ${id}B` }
                };
            });

            let gameState = {};
            let audioCtx;
            const sounds = { flip: null, match: null, mismatch: null, win: null };

            const resetGameState = () => {
                const layout = document.querySelector('input[name="layout"]:checked')?.value || '4x4';
                const playerName = gameState.playerName || "Jogador";

                gameState = {
                    flippedCards: [],
                    matchedPairs: 0,
                    lockBoard: false,
                    gameStarted: false,
                    timerInterval: null,
                    seconds: 0,
                    attempts: 0,
                    combo: 0,
                    maxCombo: 0,
                    score: 0,
                    playerName: playerName,
                    layout: layout
                };
            };

            function startGame() {
                const playerNameInput = ui.inputs.playerName;
                const playerName = playerNameInput.value.trim();

                if (!playerName) {
                    playerNameInput.classList.add('invalid');
                    setTimeout(() => playerNameInput.classList.remove('invalid'), 2000);
                    playerNameInput.focus();
                    announce("Por favor, digite seu nome para iniciar.");
                    return;
                }

                if (gameState.timerInterval) clearInterval(gameState.timerInterval);

                resetGameState();
                gameState.playerName = playerName;

                updateStats();
                createBoard();
                showScreen(ui.screens.game);
                announce("Jogo iniciado! Encontre os pares.");
            }

            function endGame() {
                clearInterval(gameState.timerInterval);
                sounds.win?.();
                updateFavicon('win');
                if (typeof confetti === 'function') {
                    confetti({ particleCount: 150, spread: 90, origin: { y: 0.6 } });
                }

                const scorePenalty = (gameState.seconds * GAME_CONFIG.TIME_PENALTY_PER_SECOND) + (gameState.attempts * GAME_CONFIG.ATTEMPT_PENALTY);
                const finalScore = Math.max(0, gameState.score - scorePenalty);

                saveScore(gameState.playerName, finalScore);

                ui.endScreen.playerName.textContent = gameState.playerName;
                ui.endScreen.finalTime.textContent = formatTime(gameState.seconds);
                ui.endScreen.finalAttempts.textContent = gameState.attempts;
                ui.endScreen.finalCombo.textContent = `x${gameState.maxCombo}`;
                ui.endScreen.finalScore.textContent = finalScore;
                displayPlayerRank(gameState.playerName, finalScore);

                announce(`Fim de jogo! Sua pontuação foi ${finalScore}.`);
                setTimeout(() => showScreen(ui.screens.end), 800);
            }

            function handleCardInteraction(event) {
                const card = event.target.closest('.card');
                if (!card || gameState.lockBoard || card.classList.contains('flipped') || card.classList.contains('matched')) return;

                if (!gameState.gameStarted) {
                    gameState.gameStarted = true;
                    startTimer();
                }

                sounds.flip?.();
                card.classList.add('flipped');
                gameState.flippedCards.push(card);

                if (gameState.flippedCards.length === 2) {
                    gameState.lockBoard = true;
                    gameState.attempts++;
                    updateStats();
                    checkForMatch();
                }
            }

            function checkForMatch() {
                const [cardOne, cardTwo] = gameState.flippedCards;
                const isMatch = cardOne.dataset.key === cardTwo.dataset.key;

                cardOne.classList.add(isMatch ? 'correct' : 'wrong');
                cardTwo.classList.add(isMatch ? 'correct' : 'wrong');

                setTimeout(() => {
                    isMatch ? handleCorrectMatch(cardOne, cardTwo) : handleWrongMatch(cardOne, cardTwo);
                }, isMatch ? 600 : 1000);
            }

            function handleCorrectMatch(cardOne, cardTwo) {
                sounds.match?.();
                announce("Par encontrado!");

                gameState.combo++;
                gameState.maxCombo = Math.max(gameState.maxCombo, gameState.combo);
                if (gameState.combo > 1) {
                    ui.feedback.combo.textContent = `COMBO x${gameState.combo}!`;
                    ui.feedback.combo.classList.add('active');
                    setTimeout(() => ui.feedback.combo.classList.remove('active'), 1500);
                }
                gameState.score += GAME_CONFIG.BASE_SCORE_PER_MATCH + (gameState.combo * GAME_CONFIG.COMBO_BONUS);
                updateStats();

                cardOne.classList.remove('correct');
                cardTwo.classList.remove('correct');
                cardOne.classList.add('matched');
                cardTwo.classList.add('matched');
                cardOne.setAttribute('tabindex', '-1');
                cardTwo.setAttribute('tabindex', '-1');
                gameState.matchedPairs++;

                resetTurn();
                if (gameState.matchedPairs === GAME_CONFIG.PAIRS_PER_GAME) {
                    endGame();
                }
            }

            function handleWrongMatch(cardOne, cardTwo) {
                sounds.mismatch?.();
                announce("Não é um par. Tente novamente.");
                gameState.combo = 0;

                cardOne.classList.remove('wrong', 'flipped');
                cardTwo.classList.remove('wrong', 'flipped');

                resetTurn();
            }

            const resetTurn = () => {
                gameState.flippedCards = [];
                gameState.lockBoard = false;
            };

            function createBoard() {
                const board = ui.game.board;
                board.innerHTML = '';
                board.className = 'memory-game-board';
                board.classList.add(gameState.layout === '4x4' ? 'layout--4x4' : 'layout--8x2');

                const selectedPairs = shuffleArray([...ALL_PAIRS_DATA]).slice(0, GAME_CONFIG.PAIRS_PER_GAME);
                const gameCardsData = selectedPairs.flatMap(p => [
                    { image: p.partA.imageFront, key: p.pairKey, type: 'A', alt: p.partA.altText },
                    { image: p.partB.imageFront, key: p.pairKey, type: 'B', alt: p.partB.altText }
                ]);
                const shuffledCards = shuffleArray(gameCardsData);

                const fragment = document.createDocumentFragment();
                shuffledCards.forEach((cardData, index) => {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'card';
                    cardEl.dataset.key = cardData.key;
                    cardEl.style.animationDelay = `${index * 50}ms`;
                    cardEl.setAttribute('tabindex', '0');
                    cardEl.setAttribute('role', 'button');
                    cardEl.ariaLabel = `Carta, ${cardData.alt}`;

                    const backImageSrc = cardData.type === 'A'
                        ? 'assets/images/cartas_memoria-CAPA-2.png'
                        : 'assets/images/cartas_memoria-CAPA-1.png';

                    cardEl.innerHTML = `
                            <div class="card-inner">
                                <div class="card-face card-face--back">
                                    <img src="${backImageSrc}" alt="Verso da carta">
                                </div>
                                <div class="card-face card-face--front">
                                    <img src="${cardData.image}" alt="${cardData.alt}">
                                </div>
                            </div>`;
                    fragment.appendChild(cardEl);
                });
                board.appendChild(fragment);
            }

            const showScreen = screen => {
                Object.values(ui.screens).forEach(s => s.classList.remove('active'));
                screen.classList.add('active');

                if (screen === ui.screens.game) {
                    ui.header.style.display = 'none';
                    ui.game.hud.style.display = 'flex';
                } else {
                    ui.header.style.display = 'block';
                    ui.game.hud.style.display = 'none';
                }
            };

            function showMainMenu() {
                if (gameState.timerInterval) clearInterval(gameState.timerInterval);
                const currentName = gameState.playerName;
                resetGameState();
                gameState.playerName = currentName;
                ui.inputs.playerName.value = (gameState.playerName !== "Jogador") ? gameState.playerName : "";
                updateFavicon('default');
                showScreen(ui.screens.start);
            }

            function updateStats() {
                ui.game.time.textContent = formatTime(gameState.seconds);
                ui.game.attempts.textContent = gameState.attempts;
                ui.game.score.textContent = gameState.score;
            }

            const getScores = () => JSON.parse(localStorage.getItem(GAME_CONFIG.LEADERBOARD_KEY)) || [];

            function saveScore(name, score) {
                const scores = getScores();
                scores.push({ name, score });
                scores.sort((a, b) => b.score - a.score);
                localStorage.setItem(GAME_CONFIG.LEADERBOARD_KEY, JSON.stringify(scores.slice(0, 10)));
            }

            function displayLeaderboard() {
                const scores = getScores();
                ui.modal.leaderboard.innerHTML = scores.length
                    ? scores.map((s, i) => `<li><span>#${i + 1} <span class="score-name">${s.name}</span></span> <span class="score-value">${s.score} pts</span></li>`).join('')
                    : '<li>Nenhum recorde ainda. Seja o primeiro!</li>';
            }

            function displayPlayerRank(name, score) {
                const scores = getScores();
                const rank = scores.findIndex(s => s.name === name && s.score === score);
                ui.endScreen.rank.textContent = (rank !== -1)
                    ? `Sua Posição no Ranking: #${rank + 1}`
                    : "Sua pontuação não entrou no Top 10.";
            }

            const shuffleArray = (arr) => {
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            };

            const formatTime = s => `${String(Math.floor(s / 60)).padStart(2, '0')}:${String(s % 60).padStart(2, '0')}`;
            const announce = msg => { ui.feedback.announcer.textContent = msg; };

            function startTimer() {
                if (gameState.timerInterval) clearInterval(gameState.timerInterval);
                gameState.timerInterval = setInterval(() => {
                    gameState.seconds++;
                    updateStats();
                }, 1000);
            }

            function updateFavicon(status = 'default') {
                const canvas = document.createElement('canvas');
                canvas.width = 32; canvas.height = 32;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#232b56';
                ctx.fillRect(0, 0, 32, 32);
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                if (status === 'win') {
                    ctx.fillStyle = '#759e56';
                    ctx.font = 'bold 24px sans-serif';
                    ctx.fillText('✓', 16, 18);
                } else {
                    ctx.fillStyle = '#d3cc9e';
                    ctx.font = 'bold 16px "Inter", sans-serif';
                    ctx.fillText('LM', 16, 16);
                }
                const link = document.querySelector("link[rel~='icon']");
                if (link) {
                    link.href = canvas.toDataURL('image/png');
                }
            }

            function setupAudio() {
                if (audioCtx) return;
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

                    sounds.flip = () => {
                        if (!audioCtx) return;
                        const bufferSize = audioCtx.sampleRate * 0.1;
                        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                        const output = buffer.getChannelData(0);
                        for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; }
                        const whiteNoise = audioCtx.createBufferSource();
                        whiteNoise.buffer = buffer;
                        const filter = audioCtx.createBiquadFilter();
                        filter.type = 'bandpass';
                        filter.frequency.setValueAtTime(1500, audioCtx.currentTime);
                        filter.Q.setValueAtTime(2, audioCtx.currentTime);
                        const gain = audioCtx.createGain();
                        gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                        whiteNoise.connect(filter).connect(gain).connect(audioCtx.destination);
                        whiteNoise.start();
                        whiteNoise.stop(audioCtx.currentTime + 0.1);
                    };

                    sounds.mismatch = () => {
                        if (!audioCtx) return;
                        const osc = audioCtx.createOscillator();
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                        const gain = audioCtx.createGain();
                        gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                        osc.connect(gain).connect(audioCtx.destination);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.15);
                    };

                    sounds.match = () => {
                        if (!audioCtx) return;
                        const notes = [[523.25, 0.2, 0], [659.25, 0.3, 0.05]];
                        notes.forEach(([freq, duration, delay]) => {
                            const osc = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            osc.type = 'sine';
                            osc.frequency.setValueAtTime(freq, audioCtx.currentTime + delay);
                            gain.gain.setValueAtTime(0.2, audioCtx.currentTime + delay);
                            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + delay + duration);
                            osc.connect(gain).connect(audioCtx.destination);
                            osc.start(audioCtx.currentTime + delay);
                            osc.stop(audioCtx.currentTime + delay + duration);
                        });
                    };

                    sounds.win = () => {
                        if (!audioCtx) return;
                        const notes = [[523.25, 0.1, 0], [659.25, 0.1, 0.1], [783.99, 0.1, 0.2], [1046.50, 0.2, 0.3]];
                        notes.forEach(([freq, duration, delay]) => {
                            const osc = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            osc.type = 'sine';
                            osc.frequency.setValueAtTime(freq, audioCtx.currentTime + delay);
                            gain.gain.setValueAtTime(0.2, audioCtx.currentTime + delay);
                            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + delay + duration);
                            osc.connect(gain).connect(audioCtx.destination);
                            osc.start(audioCtx.currentTime + delay);
                            osc.stop(audioCtx.currentTime + delay + duration);
                        });
                    };

                } catch (e) {
                    console.error("Web Audio API is not supported in this browser");
                }
            }

            function setupParticleCanvas() {
                const canvas = document.getElementById('particle-canvas');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                let particles = [];
                const resizeCanvas = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
                const createParticles = () => {
                    particles = [];
                    const particleCount = Math.floor((canvas.width * canvas.height) / 20000);
                    for (let i = 0; i < particleCount; i++) {
                        particles.push({
                            x: Math.random() * canvas.width, y: Math.random() * canvas.height,
                            radius: Math.random() * 1.5 + 0.5, speedX: (Math.random() - 0.5) * 0.3,
                            speedY: (Math.random() - 0.5) * 0.3, opacity: Math.random() * 0.5 + 0.2,
                        });
                    }
                };
                const animateParticles = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    particles.forEach(p => {
                        p.x += p.speedX; p.y += p.speedY;
                        if (p.x < 0 || p.x > canvas.width) p.speedX *= -1;
                        if (p.y < 0 || p.y > canvas.height) p.speedY *= -1;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(211, 204, 158, ${p.opacity})`;
                        ctx.fill();
                    });
                    requestAnimationFrame(animateParticles);
                };
                window.addEventListener('resize', () => { resizeCanvas(); createParticles(); });
                resizeCanvas();
                createParticles();
                animateParticles();
            }

            function setupEventListeners() {
                ui.buttons.start.addEventListener('click', startGame);
                [ui.buttons.restart, ui.buttons.playAgain].forEach(btn => btn.addEventListener('click', startGame));
                [ui.buttons.mainMenuGame, ui.buttons.mainMenuEnd].forEach(btn => btn.addEventListener('click', showMainMenu));

                ui.game.board.addEventListener('click', handleCardInteraction);
                ui.game.board.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter' || event.key === ' ') {
                        event.preventDefault();
                        handleCardInteraction({ target: document.activeElement });
                    }
                });

                document.querySelectorAll('.layout-options label').forEach(label => {
                    label.addEventListener('keydown', (event) => {
                        if (event.key === 'Enter' || event.key === ' ') {
                            event.preventDefault();
                            document.getElementById(label.getAttribute('for')).click();
                        }
                    });
                });

                let lastFocusedElement;
                const openModal = () => {
                    lastFocusedElement = document.activeElement;
                    displayLeaderboard();
                    ui.modal.overlay.classList.add('active');
                    ui.buttons.closeModal.focus();
                };
                const closeModal = () => {
                    ui.modal.overlay.classList.remove('active');
                    if (lastFocusedElement) lastFocusedElement.focus();
                };

                ui.buttons.showScores.addEventListener('click', openModal);
                ui.buttons.closeModal.addEventListener('click', closeModal);
                ui.modal.overlay.addEventListener('click', e => { if (e.target === e.currentTarget) closeModal(); });

                document.addEventListener('keydown', e => {
                    const isModalOpen = ui.modal.overlay.classList.contains('active');
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        if (isModalOpen) {
                            closeModal();
                        } else if (ui.screens.game.classList.contains('active')) {
                            ui.buttons.mainMenuGame.click();
                        } else if (ui.screens.end.classList.contains('active')) {
                            ui.buttons.mainMenuEnd.click();
                        }
                    }
                });

                document.addEventListener('click', setupAudio, { once: true });
            }

            function init() {
                resetGameState();
                ui.inputs.playerName.value = "";
                updateFavicon('default');
                setupParticleCanvas();
                setupEventListeners();
                showScreen(ui.screens.start);
            }

            init();
        });
    </script>
</body>

</html>